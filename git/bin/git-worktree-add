#!/usr/bin/env sh
# creates a worktree for a branch, copying common build artifacts
# usage: git worktree-add <branch>
#        git worktree-add --pr <number>

set -e

#
# configs
#

_PROJECT_SECRETS=".env .envrc"
_ELIXIR_ARTIFACTS="deps _build plts"
_JS_ARTIFACTS="node_modules assets"
_PROJECT_ARTIFACTS="$_PROJECT_SECRETS $_ELIXIR_ARTIFACTS $_JS_ARTIFACTS"

#
# aux functions
#

__echo_git() {
  echo "[git]: $1" >&2
}

# normalize branch path to max depth 1
# author/issue-id/description/other -> author/issue-id-description-other
__git_wt_normalize_branch_path() {
  case "$1" in
    */*/*)
      # 2+ slashes: keep first segment, join rest with dashes
      first="${1%%/*}"
      rest="${1#*/}"
      echo "$first/$(echo "$rest" | tr '/' '-')"
      ;;
    *)
      # 0-1 depth: keep as is
      echo "$1"
      ;;
  esac
}

# when we have a pr number instead, we use gh to extract the branch name
__git_wt_parse_opts_from_pr() {
  local pr_number="$1"
  local branch_name=""

  branch_name=$(gh pr view "$pr_number" --json headRefName -q '.headRefName') || {
    __echo_git "failed to fetch branch name for PR #$pr_number"
    return 1
  }

  __echo_git "PR #$pr_number -> branch: $branch_name"
  echo "$branch_name"
}

# parse the cli opts and args
__git_wt_parse_opts() {
  local branch_name=""

  while [ $# -gt 0 ]; do
    case $1 in
      --pr)
        branch_name=$(__git_wt_parse_opts_from_pr "$2") || return 1
        shift 2
        ;;
      *)
        branch_name="$1"
        shift
        ;;
    esac
  done

  echo "$branch_name"
}

# determine what the worktree path should be
# depending on whether or not we're in a worktree already
__git_wt_infer_worktree_path() {
  local git_root="$1"
  local branch_name="$2"
  local repo_name=$(basename "$git_root")
  local worktrees_base=""

  case "$git_root" in
    */.worktrees/*)
      # if already inside a .worktrees directory, create sibling
      worktrees_base="${git_root%/.worktrees/*}/.worktrees/$repo_name"
      ;;
    *)
      worktrees_base="$(dirname "$git_root")/.worktrees/$repo_name"
      ;;
  esac

  local worktree_dir=$(__git_wt_normalize_branch_path "$branch_name")
  echo "$worktrees_base/$worktree_dir"
}

__git_wt_mkdir() {
  mkdir -p "$(dirname "$1")"
}

# attach the created worktree directory either to a new branch
# or an existing one
__git_wt_attach() {
  local worktree_path="$1"
  local branch_name="$2"
  local remote_ref="refs/remotes/origin/$branch_name"

  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    # local branch exists, use it
    git worktree add "$worktree_path" "$branch_name"
  elif git show-ref --verify --quiet "$remote_ref"; then
    # remote branch exists (already fetched), track it
    git worktree add --track "$worktree_path" -b "$branch_name" "origin/$branch_name"
  elif git fetch origin "$branch_name:$remote_ref" 2>/dev/null && git show-ref --verify --quiet "$remote_ref"; then
    # remote branch exists (just fetched), track it
    git worktree add --track "$worktree_path" -b "$branch_name" "origin/$branch_name"
  else
    # new branch, add without tracking upstream
    git worktree add "$worktree_path" -b "$branch_name"
  fi
}

# copy over project artifacts so we don't have to recompile, reset secrets, etc
# this includes project-specific artifacts defined via _MNDS_LOCAL_PROJECT_ARTIFACTS
__git_wt_cp_artifacts() {
  local git_root="$1"
  local worktree_path="$2"
  local all_artifacts="$_PROJECT_ARTIFACTS $_MNDS_LOCAL_PROJECT_ARTIFACTS"

  for pattern in $all_artifacts; do
    for item in $git_root/$pattern; do
      [ -e "$item" ] || continue
      local rel_path="${item#$git_root/}"
      local dest_dir="$worktree_path/$(dirname "$rel_path")"
      mkdir -p "$dest_dir"
      cp -r "$item" "$dest_dir/" 2>/dev/null || true
    done
  done
}

#
# main script
#

branch_name=$(__git_wt_parse_opts "$@") || exit 1

if [ -z "$branch_name" ]; then
  __echo_git "branch name required"
  echo "usage: git worktree-add <branch>" >&2
  echo "       git worktree-add --pr <number>" >&2
  exit 1
fi

git_root=$(git rev-parse --show-toplevel)
worktree_path=$(__git_wt_infer_worktree_path "$git_root" "$branch_name")

if [ -d "$worktree_path" ]; then
  __echo_git "worktree already exists at $worktree_path"
  echo "$worktree_path"
  exit 0
fi

__git_wt_mkdir "$worktree_path"
__git_wt_attach "$worktree_path" "$branch_name"
__git_wt_cp_artifacts "$git_root" "$worktree_path"

__echo_git "worktree created at $worktree_path"
echo "$worktree_path"
