#!/usr/bin/env zsh

set -e

git_prefix="[git]:"
destination=$1
branch=$(git rev-parse --abbrev-ref HEAD)

_echo() {
  echo -e "$git_prefix $@"
}

_git_checkout() {
  local output=$(git checkout-worktree "$1")

  if [ -d "$output" ]; then
    cd "$output"
  fi
}

_git_rebase_or_skip() {
  # skip if worktree has unstaged changes
  if ! git diff --quiet; then
    return 0
  fi
  git rebase "$@"
}

if [ -z "$destination" ]; then
  if $(git branch-check main); then
    destination="main"
  elif $(git branch-check master); then
    destination="master"
  else
    echo "couldn't infer destination branch. main and master not here. exiting..."
    exit 1
  fi
fi

_echo "fetching origin/$destination..."
git fetch origin $destination

commits_behind=$(git rev-list --count HEAD.."remotes/origin/$destination")

if [[ $commits_behind -lt 1 ]]; then
  _echo "already up to speed with origin/$destination, no rebase needed"
  exit 0
fi

original_dir=$(pwd)

# Try to update local destination branch (master/main)
# This may fail in worktrees if the main worktree has changes - that's ok
_echo "rebasing $destination..."
_git_checkout $destination 2>/dev/null && _git_rebase_or_skip origin/$destination || true

_echo "rebasing $branch"
# cd back into where we were in case of worktrees
cd "$original_dir"
_git_checkout $branch
git rebase -i origin/$destination
